# World Model MCP Scoping and Encryption (Low-Level)

This document clarifies:
1. **How we restrict MCP to only the scoped part** of the world model (so MCP never receives the full JSONB).
2. **Exact encryption/decryption flow** at the lowest level with concrete examples.

---

## 1. How we do NOT allow MCP to use the entire JSONB

The backend stores **one encrypted blob per user** in `world_model_data`. When decrypted, that blob is a single JSON object keyed by domain, e.g.:

```json
{
  "financial": { "holdings": [...], "account_summary": {...} },
  "food": { "preferences": {...}, "dietary": "vegetarian" },
  "health": { "conditions": [...] }
}
```

**We do not give MCP this full object.** Restriction is enforced by **what the client puts into the consent export**, not by the backend filtering after decryption (the backend never decrypts).

### Mechanism (scope enforced at approval time, client-side)

1. **At approval time (in the Hushh app):**
   - The client fetches the **full** encrypted blob from the backend (e.g. `GET /api/world-model/data/{user_id}` or per-domain endpoints that return the same full blob).
   - The client decrypts it with the **vault key** (only the client has this) and obtains the full object, e.g. `full = { financial: {...}, food: {...}, health: {...} }`.
   - The client then **filters by the requested scope**:
     - If scope is `world_model.read` → use full object (all domains).
     - If scope is `attr.food.*` → use only the food domain: `scopeData = { food: full.food }`.
     - If scope is `attr.financial.*` → `scopeData = { financial: full.financial }`.
   - The client **re-encrypts only this scoped payload** with a new **export key** and sends that ciphertext (plus IV, tag, export key) to the backend. So the backend stores **one ciphertext that decrypts to the scoped subset only**.

2. **When MCP fetches data:**
   - MCP calls `GET /api/consent/data?consent_token=...` and receives:
     - `encrypted_data` (ciphertext),
     - `iv`, `tag`,
     - `export_key`.
   - The backend **never decrypts** this. It just returns what was stored.
   - MCP decrypts with the export key. The **plaintext is exactly what the client put in**—i.e. only the scoped slice (e.g. `{ "food": { ... } }`). The full world model JSONB is never in that ciphertext, so MCP **cannot** use the rest; it was never sent.

So: **we are not allowing MCP to use the whole JSONB by never including the whole JSONB in the export.** The export payload is built client-side to contain only the in-scope domain(s). No server-side filtering of decrypted data is needed (and the server never sees plaintext).

---

## 2. Exact encryption/decryption flow (lowest level)

All symmetric encryption here is **AES-256-GCM**. Keys are 32 bytes (256 bits), represented as hex strings (64 hex chars). IVs are 12 bytes; auth tag 16 bytes. Ciphertext + tag are often stored separately; for decryption, tag is appended to ciphertext.

### Notation

- `K_vault` = user’s vault key (hex, 64 chars). Only in the user’s client (and optionally in a secure vault). Backend never has it.
- `K_export` = one-time export key (hex, 64 chars). Generated by the client at approval time; stored with the consent export so MCP can decrypt.
- `Enc(K, plaintext)` = AES-256-GCM encrypt with key K, random IV; outputs (ciphertext, iv, tag).
- `Dec(K, ciphertext, iv, tag)` = AES-256-GCM decrypt.

---

### Step A: Storing world model data (user / app writes)

**Where:** Client (e.g. [lib/vault/encrypt.ts](hushh-webapp/lib/vault/encrypt.ts) `encryptData`, or Capacitor HushhVault plugin).

**Input (example):**
- Plaintext: one JSON string for the **whole** world model, e.g.  
  `plaintext = JSON.stringify({ financial: { holdings: [...] }, food: { preferences: {...} } })`
- Key: `K_vault` (user’s vault key).

**Client does:**
1. `(ciphertext, iv, tag) = Enc(K_vault, plaintext)` (e.g. Web Crypto `crypto.subtle.encrypt` with AES-GCM).
2. Encode as base64 for transport.
3. Send to backend: `POST /api/world-model/store-domain` with `encrypted_blob: { ciphertext, iv, tag }`, plus `summary` for index.

**Backend does:**
- Stores in `world_model_data`: `encrypted_data_ciphertext`, `encrypted_data_iv`, `encrypted_data_tag`.
- Updates `world_model_index_v2` (e.g. `available_domains`, `domain_summaries`).
- **Backend never has K_vault and never decrypts.**

**Example (conceptual):**
```text
plaintext = '{"financial":{"holdings":[]},"food":{"diet":"veg"}}'
K_vault = "a1b2c3d4...64 hex chars..."
(ciphertext_b64, iv_b64, tag_b64) = encryptData(plaintext, K_vault)
→ Backend stores ciphertext_b64, iv_b64, tag_b64 in world_model_data
```

---

### Step B: User approves consent (build scoped export)

**Where:** Client [use-consent-actions.ts](hushh-webapp/lib/consent/use-consent-actions.ts) (approve handler).

**Input:**
- Pending request with e.g. `scope = "attr.food.*"`.
- User has already unlocked vault (client has `K_vault`).

**Client does:**

1. **Fetch full blob from backend**  
   - e.g. `GET /api/world-model/data/{user_id}` (or per-domain if you add it).  
   - Response: `{ ciphertext, iv, tag }` (the same blob stored in Step A).

2. **Decrypt with vault key**  
   - `full_plaintext = Dec(K_vault, ciphertext, iv, tag)`  
   - e.g. [lib/vault/encrypt.ts](hushh-webapp/lib/vault/encrypt.ts) `decryptData(payload, K_vault)`.  
   - `full = JSON.parse(full_plaintext)` → e.g. `{ financial: {...}, food: {...} }`.

3. **Scope filter (this is where we restrict MCP)**  
   - Parse scope (e.g. `attr.food.*` → domain `food`).  
   - `scopeData = { food: full.food }` (only the domains that are in scope).  
   - If scope is `world_model.read`, `scopeData = full`.

4. **Generate export key and re-encrypt only scopeData**  
   - `K_export = generateExportKey()` → 32 random bytes as hex (e.g. [lib/vault/export-encrypt.ts](hushh-webapp/lib/vault/export-encrypt.ts)).  
   - `payload = JSON.stringify(scopeData)` (only the scoped slice).  
   - `(ciphertext2, iv2, tag2) = Enc(K_export, payload)` (e.g. `encryptForExport(payload, K_export)`).

5. **Send to backend**  
   - `POST /api/consent/pending/approve` with:
     - `encryptedData = ciphertext2`, `encryptedIv = iv2`, `encryptedTag = tag2`, `exportKey = K_export`,
     - plus `userId`, `requestId`, etc.

**Backend does:**
- Issues consent token, then calls e.g. [ConsentDBService.store_consent_export](consent-protocol/hushh_mcp/services/consent_db.py): stores `consent_token`, `encrypted_data = ciphertext2`, `iv = iv2`, `tag = tag2`, `export_key = K_export`, `scope`, `expires_at` in `consent_exports`.
- **Backend never decrypts; it never sees scopeData or full world model.**

**Example (conceptual):**
```text
# After step 2 on client:
full = { "financial": { "holdings": [...] }, "food": { "diet": "veg", "allergies": [] } }

# Step 3 – scope attr.food.*
scopeData = { "food": full["food"] }   # only food

# Step 4
K_export = generateExportKey()   # e.g. "f7e8d9c0...64 hex..."
payload = JSON.stringify(scopeData)   # '{"food":{"diet":"veg","allergies":[]}}'
(ciphertext2, iv2, tag2) = encryptForExport(payload, K_export)

# Step 5 – backend stores ciphertext2, iv2, tag2, K_export in consent_exports
# So the DB only ever holds ciphertext that decrypts to {"food":{...}}, not the full blob.
```

---

### Step C: MCP retrieves and decrypts (scoped data only)

**Where:** MCP tools (e.g. [mcp_modules/tools/data_tools.py](consent-protocol/mcp_modules/tools/data_tools.py)) after obtaining a consent token.

**Input:** `consent_token` (from the approve flow).

**MCP does:**

1. **Fetch export**  
   - `GET /api/consent/data?consent_token=...`  
   - Response: `{ encrypted_data, iv, tag, export_key }` (all base64 except export_key is hex).

2. **Decrypt with export key**  
   - Same AES-256-GCM as client:  
     - `key_bytes = bytes.fromhex(export_key)`  
     - `iv_bytes = base64.b64decode(iv)`, `ciphertext_bytes = base64.b64decode(encrypted_data)`, `tag_bytes = base64.b64decode(tag)`  
     - `combined = ciphertext_bytes + tag_bytes`  
     - `plaintext = AESGCM(key_bytes).decrypt(iv_bytes, combined, None)`  
   - `data = json.loads(plaintext.decode('utf-8'))`.

3. **Use data**  
   - `data` is **exactly** the object the client put in at Step B.4—e.g. `{ "food": { "diet": "veg", "allergies": [] } }`. It does **not** contain `financial` or any other domain that was out of scope.

**Backend:** Only returns the stored row from `consent_exports`; no decryption.

**Example (conceptual):**
```text
# MCP receives from GET /api/consent/data
encrypted_data = "<base64 of ciphertext2>"
iv = "<base64 of iv2>"
tag = "<base64 of tag2>"
export_key = "f7e8d9c0..."   # same K_export from approval

# MCP decrypts (e.g. Python)
plaintext = aesgcm.decrypt(iv_bytes, ciphertext_bytes + tag_bytes, None)
data = json.loads(plaintext.decode('utf-8'))
# data == {"food": {"diet": "veg", "allergies": []}}   ← only scoped slice
# MCP has no way to get financial or health; they were never in this ciphertext.
```

---

## 3. Summary diagram (data flow)

```text
[ User's device ]
  K_vault (only here)
  full blob plaintext = { financial, food, health }
        │
        │ 1) Decrypt blob with K_vault (client)
        │ 2) Filter by scope → scopeData = e.g. { food }
        │ 3) K_export = random; encrypt scopeData with K_export
        ▼
  consent export ciphertext (decrypts to scopeData only)
        │
        │ 4) POST approve: send ciphertext + iv + tag + K_export
        ▼
[ Backend ]
  Stores in consent_exports: encrypted_data, iv, tag, export_key
  Never has K_vault; never decrypts export.
        │
        │ 5) GET /api/consent/data?consent_token=...
        ▼
[ MCP ]
  Receives: encrypted_data, iv, tag, export_key
  Decrypts with export_key → plaintext = scopeData only (e.g. { food })
  Cannot access other domains: they were never in this ciphertext.
```

So: **domain scoping is enforced by the client including only the allowed domains in the plaintext that gets encrypted with the export key.** The backend and MCP never see the full world model JSONB; MCP only ever decrypts the scoped slice.
